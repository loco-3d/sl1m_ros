#! /usr/bin/env python

import numpy as np
from numpy.linalg import norm
from copy import deepcopy
import threading
import rospy
from sl1m_ros.sl1m_node import Sl1mNode
from sl1m.problem_definition import Problem
from sl1m_ros.average_quaternion import average_quaternion
from sl1m_ros.visualization_tools import foosteps_to_marker_array
from pinocchio import Quaternion

from visualization_msgs.msg import MarkerArray

# Imports for the action server
import actionlib
from pal_footstep_planner_msgs.msg import FootStepPlanAction, FootStepPlanResult
from pal_footstep_planner_msgs.msg import FootstepData
from pal_locomotion_msgs.msg import ExecFootStepsActionFeedback, ExecFootStepsActionGoal, VelocityCommandMsg
from std_srvs.srv import TriggerResponse, Trigger

MIN_STEPS_REPLANNING = 4 # minimum number of steps remaining to use replanning

class ActionServ(object):
    def __init__(self, name):
        print("Action server sl1m init ! ")
        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            FootStepPlanAction,
            execute_cb=self.execute_cb,
            auto_start=False,
        )
        self.configure_srv = rospy.Service(
            self._action_name + "/configure", Trigger, self.configure_cb
        )
        self.visualize_publisher = rospy.Publisher(
            "/footstep_list", MarkerArray, queue_size=10
        )

        self.fsp_execution_publisher = rospy.Publisher(
            "/biped_walking_dcm_controller/footsteps_execution/goal",
            ExecFootStepsActionGoal, queue_size=1)

        rospy.Subscriber("/biped_walking_dcm_controller/footsteps_execution/feedback",ExecFootStepsActionFeedback , self.feedback_cb)



        # self.footStepPlan = FootstepPlannerSl1m()
        # self.cost = {"final_com": [1.0, [0.0,0.0,0.0]]}
        self.sl1m_nodes = [Sl1mNode(), Sl1mNode()] # for starting with left feet or right feet
        # setup problem starting with right feet:
        self.sl1m_nodes[1].params.limbs.reverse()
        rospy.loginfo("Limbs for problem 0 %s" % self.sl1m_nodes[0].params.limbs)
        rospy.loginfo("Limbs for problem 1 %s" % self.sl1m_nodes[1].params.limbs)
        self.sl1m_nodes[1].problem = Problem(
            limb_names=self.sl1m_nodes[1].params.limbs,
            constraint_paths=self.sl1m_nodes[1].params.paths,
            suffix_com=self.sl1m_nodes[1].params.suffix_com,
            suffix_feet=self.sl1m_nodes[1].params.suffix_feet,
        )

        lf_color = [0.0, 1.0, 0.0]
        rf_color = [1.0, 0.0, 0.0]
        self.color_markers = [[lf_color, rf_color], [rf_color, lf_color]]  # green for left and red for right side
        self.foot_size = [0.2,0.1, 0.02]
        if rospy.has_param(
            "/biped_walking_dcm_controller/biped_parameters/foot_description/foot_length"
        ):
            self.foot_size[0] = rospy.get_param(
                "/biped_walking_dcm_controller/biped_parameters/foot_description/foot_length"
            )
        if rospy.has_param(
            "/biped_walking_dcm_controller/biped_parameters/foot_description/foot_with"
        ):
            self.foot_size[1] = rospy.get_param(
                "/biped_walking_dcm_controller/biped_parameters/foot_description/foot_with"
            )
        self.replanning = False
        if rospy.has_param("/sl1m/replanning"):
            self.replanning = rospy.get_param("/sl1m/replanning")
            
        self._as.start()
        self.init_feet_lever_arm = []
        # TODO : protect with mutex, only allow one plan() or replan() method running at the same time. 
        self.replan_mutex = threading.Lock()
        self.current_goal = None
        self.current_cost = None
        self.current_nb_steps = None
        self.current_executed_steps = None
        self.previous_executed_steps = None
        self.current_msg_seq = 1000
        self.previous_solution = None
        self.previous_first_side = 0 # 0 to start with left feet first, 1 to start with right feet first


    def convert_to_planner_result_msg(self, feet_positions, orientations):
        print("# Result from sl1m:")
        for side in range(len(feet_positions)):
            print("For side  ",side, "contact positions : ",feet_positions[side])
        print("feet position size : ", len(feet_positions[0]))
        print("base orientation size : ", len(orientations))

        # For PAL ros message FootStepData.robot_side 0 is LEFT, 1 is RIGHT
        # for SL1M indexes are in the order of the the "limbs" definition in the yaml file

        assert len(feet_positions[0]) == len(feet_positions[1])

        footsteps = []

        for i in range(1, len(feet_positions[0])):
            for side in range(len(feet_positions)):
                if feet_positions[side][i] is not None:
                    footStepDat = FootstepData()
                    footStepDat.location.x = feet_positions[side][i][0]
                    footStepDat.location.y = feet_positions[side][i][1]
                    footStepDat.location.z = feet_positions[side][i][2]
                    # footStepDat.location.z = 0. # fix for test on robot
                    footStepDat.robot_side = side
                    rot = Quaternion(orientations[i])
                    footStepDat.orientation.w = rot.w
                    footStepDat.orientation.x = rot.x
                    footStepDat.orientation.y = rot.y
                    footStepDat.orientation.z = rot.z
                    footStepDat.origin = 1
                    footsteps.append(footStepDat)

        result = FootStepPlanResult()
        result.footsteps = footsteps
        result.error_type = 0
        return result
    
    def convert_to_execution_msg(self,feet_positions, orientations):
        print("# Result from sl1m:")
        for side in range(len(feet_positions)):
            print("For side  ",side, "contact positions : ",feet_positions[side])
        print("feet position size : ", len(feet_positions[0]))
        print("base orientation size : ", len(orientations))
        result = ExecFootStepsActionGoal()
        # Fill header and metadata
        result.header.seq = self.current_msg_seq
        self.current_msg_seq += 1
        result.header.stamp = rospy.get_rostime()
        result.goal_id.stamp = result.header.stamp
        result.goal.feedback_frequency = 10.0
        # Start the commad list
        footsteps = []
        for i in range(1, len(feet_positions[0])):
            for side in range(len(feet_positions)):
                if feet_positions[side][i] is not None:
                    footStepDat = VelocityCommandMsg()
                    footStepDat.support_type.support_type = 22
                    # side: 10 for LEFT, 11 for RIGHT. Side in sl1m result depend on the first feet of the contact sequence
                    footStepDat.side.side = 10 + ((side + self.previous_first_side) % 2)
                    footStepDat.has_side = True
                    footStepDat.use_pose = True
                    footStepDat.stance_pose.position.x = feet_positions[side][i][0]
                    footStepDat.stance_pose.position.y = feet_positions[side][i][1]
                    footStepDat.stance_pose.position.z = feet_positions[side][i][2]
                    # footStepDat.location.z = 0. # fix for test on robot
                    rot = Quaternion(orientations[i])
                    footStepDat.stance_pose.orientation.w = rot.w
                    footStepDat.stance_pose.orientation.x = rot.x
                    footStepDat.stance_pose.orientation.y = rot.y
                    footStepDat.stance_pose.orientation.z = rot.z
                    footsteps.append(footStepDat)

        result.goal.commands = footsteps
        return result

    def set_initial_state(self, goal):
        if len(goal.origin_pose) != 2:
            raise Exception(
                "Goal message should contain the position of the two initial contacts"
            )
        self.sl1m_nodes[0].initial_contacts_mutex.acquire()
        for i in range(2):
            side = int(goal.origin_pose[i].robot_side)
            self.sl1m_nodes[0].initial_contacts[side][:] = [
                goal.origin_pose[i].location.x,
                goal.origin_pose[i].location.y,
                goal.origin_pose[i].location.z,
            ]

            self.sl1m_nodes[0].initial_orientations[side][::] = [
                goal.origin_pose[i].orientation.x,
                goal.origin_pose[i].orientation.y,
                goal.origin_pose[i].orientation.z,
                goal.origin_pose[i].orientation.w,
            ]
        print("Initial contacts : ", self.sl1m_nodes[0].initial_contacts)
        orientation_list = average_quaternion(
            self.sl1m_nodes[0].initial_orientations
        )
        self.sl1m_nodes[0].initial_orientation = Quaternion(
            orientation_list[3],
            orientation_list[0],
            orientation_list[1],
            orientation_list[2],
        )
        self.sl1m_nodes[0].initial_contacts_mutex.release()
        return
    

    def set_initial_state_from_feedback(self, executed_commands, sl1m_node, current_side, steps_since_last_plan):
        sl1m_node.initial_contacts_mutex.acquire()
        last_command = executed_commands[-1]
        sl1m_node.initial_contacts[0][:] = [
            last_command.stance_pose.position.x,
            last_command.stance_pose.position.y,
            last_command.stance_pose.position.z,
        ]
        sl1m_node.initial_orientations[0][::] = [
            last_command.stance_pose.orientation.x,
            last_command.stance_pose.orientation.y,
            last_command.stance_pose.orientation.z,
            last_command.stance_pose.orientation.w,
        ]

        # now set the other side with the next contact (the one currently being executed)
        # compute the index of this step in the previous solution :
        id_previous_sol = steps_since_last_plan # + self.first_replan
        side_previous_solution = (1 + current_side + self.previous_first_side) %2
        rospy.loginfo("Id in previous solution : %d " % id_previous_sol)
        rospy.loginfo("Swing id in previous solution : %d " % side_previous_solution)
        next_position = self.previous_solution[0].all_feet_pos[side_previous_solution][id_previous_sol]
        if next_position is None:
            rospy.logwarn("set_initial_state_from_feedback: defined foot is not the swing foot in the previous solution, use the next one")
            next_position = self.previous_solution[0].all_feet_pos[side_previous_solution][id_previous_sol+1]

        next_rot = Quaternion(self.previous_solution[1][id_previous_sol])
        sl1m_node.initial_contacts[1][:] = [
            next_position[0],
            next_position[1],
            next_position[2],
        ]
        sl1m_node.initial_orientations[1][::] = [
            next_rot.x,
            next_rot.y, 
            next_rot.z,
            next_rot.w
        ]

        print("Initial contacts : ", sl1m_node.initial_contacts)
        orientation_list = average_quaternion(
            sl1m_node.initial_orientations
        )
        sl1m_node.initial_orientation = Quaternion(
            orientation_list[3],
            orientation_list[0],
            orientation_list[1],
            orientation_list[2],
        )
        sl1m_node.initial_contacts_mutex.release()
        return

    def set_goal(self, goal, problem_id = 0):
        # print("Set goal called, goal message = ", goal)
        x = goal.target_pose.position.x
        y = goal.target_pose.position.y
        z = goal.target_pose.position.z
        target_ground = np.array([x, y, z])
        target_com = [x, y, z + self.sl1m_nodes[problem_id].params.com_height]
        self.sl1m_nodes[problem_id].destination_contacts_mutex.acquire()
        self.sl1m_nodes[problem_id].destination_orientation = Quaternion(
            goal.target_pose.orientation.w,
            goal.target_pose.orientation.x,
            goal.target_pose.orientation.y,
            goal.target_pose.orientation.z,
        )
        target_end_effector_positions = [np.zeros(3) for _ in self.sl1m_nodes[problem_id].params.limbs]
        if len(target_end_effector_positions) == 2:
            target_end_effector_positions[0] = target_ground + self.sl1m_nodes[problem_id].destination_orientation.matrix().dot(np.array([0, 0.1, 0]))
            target_end_effector_positions[1] = target_ground + self.sl1m_nodes[problem_id].destination_orientation.matrix().dot(np.array([0, -0.1, 0]))
        self.sl1m_nodes[problem_id].destination_contacts_mutex.release()

        costs = {
            # We want to reach the destination.
            # "final_com": [10, target_com],
            # We want to have the feet aligned with the CoM in the coronal plane.
            "end_effector_positions": [100.0, target_end_effector_positions],
            # We want to keep a posture close to the half-sitting one
            # "posture": [10.0],
            # Default offset from the optimal
            "step_size": [1., [0.1, 0.0]]
        }
        rospy.loginfo("costs : {}".format(costs))
        return costs

    def visualize_footsteps(self, feet_positions, orientations, current_side = 0):
        self.visualize_publisher.publish(MarkerArray())
        marker_array = foosteps_to_marker_array(
            feet_positions,
            orientations,
            rospy.Time.now(),
            self.foot_size,
            self.color_markers[current_side],
        )
        # print("Marker array for visualization size : ", len(marker_array.markers))
        # print("array : ", marker_array)
        self.visualize_publisher.publish(marker_array)

    def plan(self, goal):
        self.current_goal = goal
        self.set_initial_state(goal)
        nb_steps = self.sl1m_nodes[0].compute_nb_steps(goal)
        costs = self.set_goal(goal, 0)
        costs = self.set_goal(goal, 1) # prepare the problem for the other feet first, in case of replanning
        self.current_cost = costs
        self.current_nb_steps = nb_steps
        self.previous_solution = self.sl1m_nodes[0].run_once(nb_steps, costs, add_initial_surface=False)
        return self.previous_solution
    
    def validate_new_solution(self, previous_sol, current_sol, steps_diff, treshold_distance = 0.3):
        change_side = steps_diff % 2 # if true, the indexing of the side change between both solutions
        pos1_current = current_sol.all_feet_pos[0][1]
        pos2_current =  current_sol.all_feet_pos[1][2]
        rospy.logdebug("validate solution:")
        pos1_previous = previous_sol.all_feet_pos[change_side][1+steps_diff]
        pos2_previous =  previous_sol.all_feet_pos[(change_side + 1) % 2][2+steps_diff]
        rospy.logdebug("pos 1 current : %s" % pos1_current)
        rospy.logdebug("pos 1 previous: %s" % pos1_previous)
        rospy.logdebug("pos 2 current : %s" % pos2_current)
        rospy.logdebug("pos 2 previous: %s" % pos2_previous)
        if norm(np.array(pos1_current - pos1_previous)) > treshold_distance:
            rospy.logwarn("First step of the new solution is too far from the original solution, discard solution.")
            return False
        if norm(np.array(pos2_current - pos2_previous)) > treshold_distance:
            rospy.logwarn("Second step of the new solution is too far from the original solution, discard solution.")
            return False   
        return True

    def replan(self, executed_commands):
        rospy.loginfo("SL1M replan called!!")
        steps_since_last_plan = self.current_executed_steps - self.previous_executed_steps        
        rospy.loginfo("Replan, previous number of steps : %d " % self.previous_executed_steps)
        rospy.loginfo("Replan, steps since last plan : %d " % steps_since_last_plan)
        current_side = executed_commands[-1].side.side - 10
        rospy.loginfo("Replan, previous first side : %d" % self.previous_first_side)
        rospy.loginfo("Replan, current side in feedback %d" % current_side)
        sl1m_node = self.sl1m_nodes[current_side] 
        self.set_initial_state_from_feedback(executed_commands, sl1m_node, current_side, steps_since_last_plan)
        #nb_steps = self.current_nb_steps - steps_since_last_plan
        nb_steps = sl1m_node.compute_nb_steps(self.current_goal)
        rospy.loginfo("Num steps: %d" % nb_steps)
        if nb_steps < MIN_STEPS_REPLANNING:
            self.current_nb_steps = nb_steps
            rospy.logwarn("Replan: number of steps remaining under treshold. Do not compute new plan")
            return None, None, None
        sol = sl1m_node.run_once(nb_steps, self.current_cost, add_initial_surface=False)
        if sol[0].success:
            if self.validate_new_solution(self.previous_solution[0], sol[0], steps_since_last_plan):
                self.previous_first_side = current_side
                self.previous_solution = sol
                self.current_nb_steps = nb_steps
                return sol[0], sol[1], current_side
            else:
                rospy.logwarn("New solution is too far from the initial one, discard it.")
        return None, None, None



    # Callback functions
    def execute_cb(self, goal):
        rospy.loginfo("Executing callback of %s" % self._action_name)
        
        if not self.sl1m_nodes[0].is_environment_valid():
            rospy.loginfo("Nothing to compute, surface list is empty")
            result_msg = FootStepPlanResult()
        # elif not self.sl1m_nodes[0].is_initial_state_valid():
        #    rospy.loginfo('Nothing to compute, initial state is not configured')
        else:
            result, orientations = self.plan(goal)
            if result.success:
                result_msg = self.convert_to_planner_result_msg(
                    result.all_feet_pos, orientations
                )
                print("result = ", result)
                self.visualize_footsteps(result.all_feet_pos, orientations)
            else:
                self._as.set_aborted(None, "Sl1m did not converge.")
                return
        rospy.loginfo(
            "Callback return succeed for Action %s" % self._action_name
        )
        print("@@@@@ replan member: ", goal.continuous_replan)
        if self.replanning:
            self.current_executed_steps = None
            self.first_side = 0
        self._as.set_succeeded(result_msg)

    def configure_cb(self, req):
        rospy.loginfo("Executing Configure of %s" % self._action_name)
        res = TriggerResponse()
        res.success = True
        res.message = ""
        return res

    def feedback_cb(self, feedback):
        #rospy.loginfo("SL1m: feedback received from execution, executed command size : %i" % len(feedback.feedback.executed_commands))
        if self.current_cost is None or self.current_nb_steps is None:
            rospy.loginfo("Feedback received but replanning was not configured yet")
            return
        if feedback.status.status != 1:
            rospy.loginfo("Feedback received with status != ACTIVE : %d" % feedback.status.status)
            return
        if len(feedback.feedback.executed_commands) <= 0:
            rospy.loginfo("Feedback received: no executed commands yet")
            return
        
        if self.current_executed_steps is None:
            self.current_executed_steps = len(feedback.feedback.executed_commands)
            self.previous_executed_steps = self.current_executed_steps

        if feedback.feedback.executed_commands[-1].support_type.support_type != 22:
            rospy.loginfo("Feedback received do not end with a SS phase : %d" % feedback.feedback.executed_commands[-1].support_type.support_type)
            return
        if self.current_nb_steps < MIN_STEPS_REPLANNING:
            rospy.loginfo("Feedback received but initial number of planned step have been executed already")
            return
        
        if len(feedback.feedback.executed_commands) > self.current_executed_steps:
            rospy.loginfo("Feedback, current number of steps executed : %d" % len(feedback.feedback.executed_commands))
            if self.replan_mutex.acquire(False):
                self.current_executed_steps = len(feedback.feedback.executed_commands)
                try:
                    result, orientations, current_side = self.replan(feedback.feedback.executed_commands)
                except Exception as exc:
                    print(exc)
                    result = None
                self.replan_mutex.release()
                if result is not None:
                    print("result of replanning = ", result)
                    self.previous_executed_steps = self.current_executed_steps
                    self.visualize_footsteps(result.all_feet_pos, orientations, current_side)
                    result_msg = self.convert_to_execution_msg(result.all_feet_pos, orientations)
                    self.fsp_execution_publisher.publish(result_msg)
                else:
                    self.current_executed_steps = self.previous_executed_steps
                    rospy.logerr("Sl1m failed to solve the problem. Will retry at next step.")

if __name__ == "__main__":
    rospy.init_node("footstep_planner")
    server = ActionServ("footstep_planner")
    rospy.spin()
