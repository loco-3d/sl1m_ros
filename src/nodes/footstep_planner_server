#! /usr/bin/env python

import rospy
import os 
import numpy as np

from sl1m_ros.sl1m_node import Sl1mNode
from sl1m_ros.average_quaternion import average_quaternion
from pinocchio import Quaternion
from pinocchio.rpy import matrixToRpy

from std_msgs.msg import Header
from visualization_msgs.msg import MarkerArray, Marker
from geometry_msgs.msg import Point

#Imports for the action server
import actionlib
from pal_footstep_planner_msgs.msg import FootStepPlanAction, FootStepPlanActionGoal, FootStepPlanResult
from gazebo_msgs.msg import ModelStates
from pal_footstep_planner_msgs.msg import FootstepData
from geometry_msgs.msg import Vector3
from std_srvs.srv import TriggerRequest, TriggerResponse, Trigger




class ActionServ(object):

    def __init__(self,name):
        print("Action server sl1m init ! ")
        self._action_name = name
        self._as = actionlib.SimpleActionServer(self._action_name, FootStepPlanAction, execute_cb=self.execute_cb, auto_start=False)
        self.configure_srv = rospy.Service(self._action_name+"/configure", Trigger, self.configure_cb)
        self.visualize_publisher = rospy.Publisher("footstep_list", MarkerArray, 1)
        self._result = FootStepPlanResult()
        #self.footStepPlan = FootstepPlannerSl1m()
        #self.cost = {"final_com": [1.0, [0.0,0.0,0.0]]}
        self.sl1m_node = Sl1mNode()
        self._as.start()
    
    def convert_sl1m_result(self, sl1m_result):
        N_STEPS = self.sl1m_node.params.nb_steps_max
        print("Result from sl1m", sl1m_result)
        print("Feet pose :", sl1m_result.all_feet_pos)

        # FIXME: this assume that the configuration for sl1m is in the order
        #    limbs:
        #- "LF"
        #- "RF"
        leftSteps = sl1m_result.all_feet_pos[0]
        rightSteps = sl1m_result.all_feet_pos[1]
        assert(len(leftSteps) == len(rightSteps))
        steps = [leftSteps,rightSteps]
        footsteps =[]
        
        print(sl1m_result)
        print("LeftSteps : \n{} \n\nRighSteps : \n{}".format(leftSteps,rightSteps))

        for i in range(1, len(leftSteps) - 1) : 
            footStepDat = FootstepData()
            footStepDat.location.x = steps[i%2][i+1][0]
            footStepDat.location.y = steps[i%2][i+1][1]
            footStepDat.location.z = steps[i%2][i+1][2]
            #footStepDat.location.z = 0. # fix for test on robot
            footStepDat.robot_side = i%2
            footStepDat.orientation.w = 1.
            footStepDat.origin = 1
            footsteps.append(footStepDat)
        
        result = FootStepPlanResult()
        result.footsteps = footsteps
        result.error_type = 0
        return result
    
    def set_initial_state(self, goal):
        if len(goal.origin_pose) != 2:
            raise Exception("Goal message should contain the position of the two initial contacts")
        self.sl1m_node.initial_contacts_mutex.acquire()
        for i in range(2):
            side = int(goal.origin_pose[i].robot_side)
            self.sl1m_node.initial_contacts[side][:]  = [goal.origin_pose[i].location.x, goal.origin_pose[i].location.y, goal.origin_pose[i].location.z]

            self.sl1m_node.initial_orientations[side][::] = [
                goal.origin_pose[i].orientation.x,
                goal.origin_pose[i].orientation.y,
                goal.origin_pose[i].orientation.z,
                goal.origin_pose[i].orientation.w,
            ]
        print("Initial contacts : ", self.sl1m_node.initial_contacts)
        orientation_list = average_quaternion(self.sl1m_node.initial_orientations)
        self.initial_orientation = Quaternion(orientation_list[3], orientation_list[0], orientation_list[1], orientation_list[2])
        self.sl1m_node.initial_contacts_mutex.release()
        return

    def set_goal(self, goal):
        #print("Set goal called, goal message = ", goal)
        x = goal.target_pose.position.x
        y = goal.target_pose.position.y
        z = goal.target_pose.position.z
        target_com = [x, y, z + self.sl1m_node.params.com_height]
        costs = {"final_com": [1.0, target_com],
                 "posture":[1]
                 #"step_size": [10.0, 0.2]
                 }
        self.sl1m_node.destination_contacts_mutex.acquire()
        self.sl1m_node.destination_orientation = Quaternion(goal.target_pose.orientation.w,
                                                            goal.target_pose.orientation.x,
                                                            goal.target_pose.orientation.y,
                                                            goal.target_pose.orientation.z)
        self.sl1m_node.destination_contacts_mutex.release()
        print("target com for planning : ", target_com)
        print("target base orientation for planning : ", self.sl1m_node.destination_orientation)

        return costs
    
    def compute_num_steps(self, goal):
        # compute the number of steps. 
        # simple heuristic, waiting for SL1M to come up with a better solution
        self.sl1m_node.initial_contacts_mutex.acquire()
        origin_position = [self.sl1m_node.initial_contacts[0][0] + self.sl1m_node.initial_contacts[1][0] / 2.,
                           self.sl1m_node.initial_contacts[0][1] + self.sl1m_node.initial_contacts[1][1] / 2.]
        rot_origin = self.sl1m_node.initial_orientation
        self.sl1m_node.initial_contacts_mutex.release()

        self.sl1m_node.destination_contacts_mutex.acquire()
        rot_target = self.sl1m_node.destination_orientation
        self.sl1m_node.destination_contacts_mutex.release()

        print("Origin position ",origin_position)

        distance = np.linalg.norm(np.array([origin_position[0] - goal.target_pose.position.x,
                                            origin_position[1] - goal.target_pose.position.y]))
        nb_steps_lin = abs(distance / self.sl1m_node.params.step_length[0]) * 2.


        yaw = abs(matrixToRpy((rot_target * rot_origin.inverse()).matrix()))[2]
        nb_steps_rot = (yaw / self.sl1m_node.params.step_length[1]) * 2.

        nb_steps = int(min(self.sl1m_node.params.nb_steps_max, max(nb_steps_lin, nb_steps_rot)))
        print("Number of steps : ", nb_steps)
        return nb_steps

    def visualize_footsteps(self, result):
        """
        if(getPathSize() == 0)
        {
            ROS_ERROR("No path generated at this moment");
            return;
        }

        if(footsteps_visual_.markers.size() > 0)
        {
            visualization_msgs::MarkerArrayPtr empty_marray = emptyMarker(footsteps_visual_.markers.size());
            FootStepList_.publish(*empty_marray);
            ros::spinOnce();
        }

        footsteps_visual_.markers.clear();
        footsteps_visual_index_ = 0;

        if(path_.front().getLeg() == Leg::RIGHT)
            footPoseToMarker(StartFootRight_, footsteps_visual_, footsteps_visual_index_);
        else
            footPoseToMarker(StartFootLeft_, footsteps_visual_, footsteps_visual_index_);

        for(size_t i = 0; i < path_.size(); i++)
        {
            footPoseToMarker(path_[i], footsteps_visual_, footsteps_visual_index_);
            //ros::Duration(0.8).sleep();
            //FootStepList_.publish(footsteps_visual_);
            //ros::spinOnce();
        }

        FootStepList_.publish(footsteps_visual_);
        """
        return

    #Callback functions
    def execute_cb(self,goal):
        rospy.loginfo('Executing callback of %s' % self._action_name)
        #cost = self.setCost(goal)
        #print("Cost : {}".format(self.getCost()))
        result_msg = FootStepPlanResult()
        if not self.sl1m_node.is_environment_valid():
            rospy.loginfo('Nothing to compute, surface list is empty')
        #elif not self.sl1m_node.is_initial_state_valid():
        #    rospy.loginfo('Nothing to compute, initial state is not configured')
        else:
            self.set_initial_state(goal)
            costs = self.set_goal(goal)
            nb_steps = self.compute_num_steps(goal)
            result = self.sl1m_node.run_once(nb_steps, costs)
            result_msg = self.convert_sl1m_result(result)
            print("result = ", result)
            self.visualize_footsteps(result)
        rospy.loginfo('Callback return succeed for Action %s' % self._action_name)
        self._as.set_succeeded(result_msg)

    def configure_cb(self, req):
        rospy.loginfo('Executing Configure of %s' % self._action_name)
        res = TriggerResponse()
        res.success = True
        res.message = ""
        return res

if __name__ == '__main__':
    rospy.init_node("footstep_planner")
    server = ActionServ("footstep_planner")
    rospy.spin()